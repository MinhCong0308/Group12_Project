package screen.sortingApp.visualizer;
import javax.swing.JOptionPane;
import java.awt.image.BufferStrategy;
import java.awt.Color;
import java.awt.Graphics;
import screen.sortingApp.color.*;
import screen.sortingApp.bar.Bar;
import sorting.*;
import java.util.Arrays;
import java.util.Random;
import java.util.concurrent.TimeUnit;
public class Visualizer {
	private static final int PADDING = 20;
	private static final int MAX_BAR_HEIGHT = 350, MIN_BAR_HEIGHT = 30;
	private Integer [] array;
	private int speed, capacity, colo;
	private Bar[] bars;
	private boolean existedArray;
	
	
	//Value for statistic
	private long startTime, time;
	private int comp, swapping;
	
	private Color originalColor, swappingColor, comparingColor;
	private BufferStrategy bs;
	private Graphics g;
	
	private SortedListener listener;
	
	public Visualizer(int capacity, SortedListener listener) {
		this.capacity = capacity;
        //this.speed = (int) (1000.0/fps);
        this.listener = listener;
        startTime = time = comp = swapping = 0;
        originalColor = ColorManager.BAR_WHITE;
        comparingColor = Color.YELLOW;
        swappingColor = ColorManager.BAR_RED;
        bs = listener.getBufferStrategy();
        existedArray = false;
	}
	
	public void createRandomArray(int canvasWidth, int canvasHeight) {
        array = new Integer[capacity];
        bars = new Bar[capacity];
        existedArray = true;

        // initial position
        double x = PADDING;
        int y = canvasHeight- PADDING;

        // width of all bars
        double width = (double) (canvasWidth - PADDING*2) / capacity;

        // get graphics
        g = bs.getDrawGraphics();
        g.setColor(ColorManager.SORTAPP_BACKGROUND);
        g.fillRect(0, 0, canvasWidth, canvasHeight);

        Random rand = new Random();
        int value;
        Bar bar;
        for (int i = 0; i < array.length; i++)
        {
            value = rand.nextInt(MAX_BAR_HEIGHT) + MIN_BAR_HEIGHT;
            array[i] = value;

            bar = new Bar((int)x, y, (int) width, value, originalColor);
            bar.draw(g);
            bars[i] = bar;

            // move to the next bar
            x += width;
        }

        bs.show();
        g.dispose();
    }



    // for restore purpose
    public void drawArray()
    {
        if (!existedArray)
            return;

        g = bs.getDrawGraphics();

        for (int i = 0; i < bars.length; i++)
        {
            bars[i].draw(g);
        }

        bs.show();
        g.dispose();
    }

    public void setCapacity(int capacity)
    {
        this.capacity = capacity;
    }




	public interface SortedListener
    {
        void onArraySorted(long elapsedTime, int comparison, int swapping);
        BufferStrategy getBufferStrategy();
    }
	
}